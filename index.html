// src/index.js
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    if (request.method === "OPTIONS") return new Response(null, { headers: { "Access-Control-Allow-Origin": "*", "Access-Control-Allow-Methods": "GET, POST, OPTIONS", "Access-Control-Allow-Headers": "Content-Type" } });

    if (url.pathname === "/create-room" && request.method === "POST") {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let shortCode = '';
      for(let i=0; i<5; i++) shortCode += chars.charAt(Math.floor(Math.random() * chars.length));
      return new Response(JSON.stringify({ roomId: shortCode }), { headers: { "Content-Type": "application/json", "Access-Control-Allow-Origin": "*" } });
    }

    if (request.headers.get("Upgrade") === "websocket") {
      const roomId = url.searchParams.get("roomId");
      if (!roomId) return new Response("Missing roomId", { status: 400 });
      try { return env.POKER_ROOM.get(env.POKER_ROOM.idFromName(roomId)).fetch(request); } 
      catch (e) { return new Response("Invalid Room ID", { status: 400 }); }
    }
    return new Response("Poker Server V17 - Perfect Buy-In Sync");
  }
};

export class PokerRoom {
  constructor(state, env) {
    this.sessions = [];
    this.socketToName = new Map();
    this.players = [];
    this.game = { 
        status: "WAITING", pot: 0, currentBet: 0, board: [], deck: [], burnCards: [],
        turnIndex: 0, dealerIndex: -1, smallBlind: 50, bigBlind: 100, buyIn: 10000,
        winMessage: "", hostName: "" 
    };
  }

  async fetch(request) {
    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);
    this.sessions.push(server);

    server.addEventListener('message', async event => {
      try { 
        const data = JSON.parse(event.data);
        if (data.type === "JOIN") this.socketToName.set(server, data.name);
        await this.handleAction(server, data); 
      } catch (e) {}
    });

    server.addEventListener('close', () => this.handleDisconnect(server));
    server.addEventListener('error', () => this.handleDisconnect(server));

    server.accept();
    return new Response(null, { status: 101, webSocket: client });
  }

  handleDisconnect(server) {
      const playerName = this.socketToName.get(server);
      this.sessions = this.sessions.filter(s => s !== server);
      this.socketToName.delete(server);
      if (playerName) {
          setTimeout(() => {
              if (!this.isPlayerSocketActive(playerName)) {
                  const p = this.players.find(p => p.name === playerName);
                  if (p) { p.isOnline = false; this.broadcastState(); }
              }
          }, 3000);
      }
  }

  isPlayerSocketActive(playerName) {
      for (let name of this.socketToName.values()) { if (name === playerName) return true; }
      return false;
  }

  async handleAction(socket, data) {
    if (data.type === "JOIN") {
      // „ÄêÊ†∏ÂøÉ‰øÆÂ§çÔºöÊé•Êî∂Êàø‰∏ªÁöÑÂàùÂßãÊàøÈó¥ËÆæÂÆöÂü∫Âõ†„Äë
      if (data.settings) {
          this.game.buyIn = data.settings.initialChips;
          this.game.smallBlind = data.settings.smallBlind;
          this.game.bigBlind = data.settings.bigBlind;
      }

      const reqNamePart = data.name.split('|')[1] || data.name;
      let p = this.players.find(player => (player.name.split('|')[1] || player.name) === reqNamePart);
      if (!p) {
        let isMidGame = this.game.status !== "WAITING";
        this.players.push({ 
            id: crypto.randomUUID(), name: data.name, 
            chips: this.game.buyIn, totalBuyIn: this.game.buyIn, // ÂÆåÁæéÊãøÂà∞Ê≠£Á°ÆÁöÑÂ∫ïÈáë
            hand: [], folded: isMidGame, betThisRound: 0, actedThisRound: isMidGame, 
            isOut: false, winAmount: 0, isOnline: true, isWaitingNextHand: isMidGame, isKicked: false,
            isSpectating: false
        });
        if (this.players.length === 1) this.game.hostName = data.name;
      } else {
        p.name = data.name; p.isOnline = true; p.isKicked = false;
        if ((this.game.hostName.split('|')[1] || this.game.hostName) === reqNamePart) this.game.hostName = data.name;
      }
    } 
    else if (data.type === "BUY_IN") {
      const p = this.players.find(player => player.name === data.name);
      if (p) {
          const buyAmount = this.game.buyIn; // Ë°•ÂÖÖ‰πüÊòØÂÆåÁæéÁöÑÂ∫ïÈáë
          p.chips += buyAmount; 
          p.totalBuyIn += buyAmount; 
          if(p.isOut || p.isSpectating) { 
              p.isOut = false; p.isSpectating = false; 
              if (this.game.status === "WAITING") p.folded = false;
          }
      }
    }
    // „ÄêÊ†∏ÂøÉ‰øÆÂ§çÔºöÂºÄÂ±Ä‰∏çÂÜçÊó†ËÑëÂèëÈí±ÔºåÊ≤°Èí±ÁöÑËá™Âä®ÂéªËßÇÊàò„Äë
    else if (data.type === "START_GAME" && data.name === this.game.hostName) {
      const activePlayers = this.players.filter(p => p.chips > 0 && !p.isKicked && !p.isSpectating);
      if (activePlayers.length >= 2) this.startNewHand();
    }
    else if (data.type === "KICK" && data.name === this.game.hostName) {
        const targetIdx = this.players.findIndex(p => p.name === data.targetName);
        if (targetIdx !== -1) {
            const p = this.players[targetIdx];
            p.folded = true; p.isOut = true; p.isSpectating = true; p.chips = 0; p.isKicked = true; 
            if (this.game.status !== "WAITING" && this.game.status !== "SHOWDOWN") { await this.advanceTurnOrPhase(); return; }
        }
    }
    else if (data.type === "FORCE_RESTART" && data.name === this.game.hostName) {
        this.game.status = "WAITING"; this.game.currentBet = 0; this.game.board = []; this.game.burnCards = [];
        this.game.winMessage = "Êàø‰∏ªÂ∑≤Âº∫Âà∂ÁªìÊùüÂØπÂ±Ä";
        this.players.forEach(p => { p.hand = []; p.betThisRound = 0; p.investedThisHand = 0; p.folded = true; p.actedThisRound = false; p.winAmount = 0; p.isSpectating = (p.chips === 0); });
    }
    else if (data.type === "NEXT_HAND") {
      if (this.game.status === "SHOWDOWN") {
          const activePlayers = this.players.filter(p => p.chips > 0 && !p.isKicked);
          if (activePlayers.length >= 2) this.startNewHand();
          else {
              this.game.status = "WAITING"; this.game.currentBet = 0; this.game.board = []; this.game.burnCards = [];
              this.players.forEach(p => { p.hand = []; p.betThisRound = 0; p.investedThisHand = 0; p.folded = true; p.actedThisRound = false; p.winAmount = 0; p.isSpectating = (p.chips === 0); });
          }
      }
    }
    else if (data.type === "ACTION" && this.game.status !== "WAITING" && this.game.status !== "SHOWDOWN") {
      const p = this.players[this.game.turnIndex];
      if (p && p.name === data.name && !p.folded && p.chips > 0 && !p.isKicked && !p.isSpectating) { 
          await this.processPlayerAction(p, data.action, data.amount); 
          return; 
      }
    }
    this.broadcastState();
  }

  startNewHand() {
    this.game.status = "PRE-FLOP"; this.game.board = []; this.game.burnCards = []; this.game.deck = this.createDeck(); this.game.winMessage = "";
    
    this.players.forEach(p => { 
        if(p.chips <= 0) { p.isOut = true; p.isSpectating = true; p.folded = true; } 
        else { p.isOut = false; p.isSpectating = false; }
    });

    this.game.dealerIndex = this.getNextActivePlayer(this.game.dealerIndex);
    
    this.players.forEach(p => { 
        p.betThisRound = 0; p.investedThisHand = 0; p.actedThisRound = false; p.winAmount = 0; p.isWaitingNextHand = false;
        if(!p.isSpectating && !p.isKicked) { p.folded = false; p.hand = [this.game.deck.pop(), this.game.deck.pop()]; } 
    });
    
    const sbIndex = this.getNextActivePlayer(this.game.dealerIndex); const bbIndex = this.getNextActivePlayer(sbIndex);
    const sbPlayer = this.players[sbIndex]; const actualSb = Math.min(sbPlayer.chips, this.game.smallBlind);
    sbPlayer.chips -= actualSb; sbPlayer.betThisRound = actualSb; sbPlayer.investedThisHand += actualSb;
    
    const bbPlayer = this.players[bbIndex]; const actualBb = Math.min(bbPlayer.chips, this.game.bigBlind);
    bbPlayer.chips -= actualBb; bbPlayer.betThisRound = actualBb; bbPlayer.investedThisHand += actualBb;
    
    this.game.currentBet = this.game.bigBlind; this.game.turnIndex = this.getNextActivePlayer(bbIndex); 
  }

  getNextActivePlayer(startIndex) {
    if(this.players.length === 0) return 0;
    let idx = (startIndex + 1) % this.players.length;
    while (this.players[idx].isOut || this.players[idx].isSpectating || this.players[idx].folded || this.players[idx].chips === 0 || this.players[idx].isKicked) {
        idx = (idx + 1) % this.players.length; if(idx === startIndex) break;
    }
    return idx;
  }

  async processPlayerAction(player, actionType, amount) {
    player.actedThisRound = true;
    if (actionType === "FOLD") { player.folded = true; } 
    else if (actionType === "CALL") { 
        const callAmt = Math.min(player.chips, this.game.currentBet - player.betThisRound); 
        player.chips -= callAmt; player.betThisRound += callAmt; player.investedThisHand += callAmt; 
    } 
    else if (actionType === "RAISE") {
        const raiseTotal = this.game.currentBet + amount; const addAmt = Math.min(player.chips, raiseTotal - player.betThisRound);
        player.chips -= addAmt; player.betThisRound += addAmt; player.investedThisHand += addAmt; this.game.currentBet = player.betThisRound; 
        this.players.forEach(p => { if (!p.folded && !p.isOut && !p.isSpectating && !p.isKicked && p !== player && p.chips > 0) p.actedThisRound = false; });
    }
    await this.advanceTurnOrPhase();
  }

  async advanceTurnOrPhase() {
    const activePlayers = this.players.filter(p => !p.folded && !p.isOut && !p.isKicked && !p.isSpectating);
    
    if (activePlayers.length === 1) {
        const w = activePlayers[0];
        const wName = w.name.split('|')[1] || w.name;
        this.game.winMessage = `üöÄ Áé©ÂÆ∂ <span style="color:var(--gold)">${wName}</span> Ëé∑ËÉúÔºÅ(ÂÖ∂‰ΩôÂºÉÁâå)`;
        let totalPot = this.players.reduce((sum, p) => sum + p.investedThisHand, 0);
        w.chips += totalPot; w.winAmount = totalPot;
        this.players.forEach(p => { p.investedThisHand = 0; p.betThisRound = 0; });
        this.game.status = "SHOWDOWN"; this.broadcastState(); return;
    }

    const playersCanAct = activePlayers.filter(p => p.chips > 0).length;
    const isRoundOver = (playersCanAct <= 1) || activePlayers.every(p => p.chips === 0 || (p.actedThisRound && p.betThisRound === this.game.currentBet));

    if (isRoundOver) {
      this.players.forEach(p => { if (!p.folded && !p.isOut && !p.isKicked) p.actedThisRound = false; p.betThisRound = 0; });
      this.game.currentBet = 0;

      if (this.game.status === "PRE-FLOP") {
        this.game.status = "FLOP"; this.game.burnCards.push(this.game.deck.pop()); this.game.board.push(this.game.deck.pop(), this.game.deck.pop(), this.game.deck.pop()); 
      } else if (this.game.status === "FLOP") {
        this.game.status = "TURN"; this.game.burnCards.push(this.game.deck.pop()); this.game.board.push(this.game.deck.pop()); 
      } else if (this.game.status === "TURN") {
        this.game.status = "RIVER"; this.game.burnCards.push(this.game.deck.pop()); this.game.board.push(this.game.deck.pop()); 
      } else if (this.game.status === "RIVER") {
        this.evaluateShowdown(activePlayers);
        this.broadcastState(); return;
      }

      if (playersCanAct <= 1) {
          this.broadcastState(); 
          await new Promise(resolve => setTimeout(resolve, 1500)); 
          return this.advanceTurnOrPhase(); 
      }
      this.game.turnIndex = this.getNextActivePlayer(this.game.dealerIndex);
    } else {
      this.game.turnIndex = this.getNextActivePlayer(this.game.turnIndex);
    }
    this.broadcastState();
  }

  evaluateShowdown(activePlayers) {
    this.game.status = "SHOWDOWN"; 
    activePlayers.forEach(p => {
        const fullHand = [...p.hand, ...this.game.board].map(c => this.parseCard(c));
        p.finalScore = this.calculateHandRank(fullHand);
    });
    
    let messages = [];
    let potNumber = 1;

    let playersWithInvest = this.players.filter(p => p.investedThisHand > 0);
    while (playersWithInvest.length > 0) {
        let activeInvestments = activePlayers.filter(p => p.investedThisHand > 0);
        if (activeInvestments.length === 0) break; 

        let minInvest = Math.min(...activeInvestments.map(p => p.investedThisHand));
        let layerPot = 0;
        let eligiblePlayers = [];

        this.players.forEach(p => {
            if (p.investedThisHand > 0) {
                let extract = Math.min(p.investedThisHand, minInvest);
                p.investedThisHand -= extract; layerPot += extract;
                if (activePlayers.includes(p) && extract === minInvest) eligiblePlayers.push(p);
            }
        });

        if (eligiblePlayers.length === 1) {
            let w = eligiblePlayers[0];
            w.chips += layerPot; w.winAmount = (w.winAmount || 0) + layerPot;
            messages.push(`üí∏ Áé©ÂÆ∂ <span style="color:var(--gold)">${w.name.split('|')[1] || w.name}</span> ÂõûÊî∂Êú™ÂåπÈÖçÂ∫ïÊ±† $${layerPot}`);
        } else {
            let bestScore = -1; let winners = [];
            eligiblePlayers.forEach(p => {
                if (p.finalScore.value > bestScore) { bestScore = p.finalScore.value; winners = [p]; } 
                else if (p.finalScore.value === bestScore) { winners.push(p); }
            });
            
            let splitAmt = Math.floor(layerPot / winners.length);
            let winnerNames = [];
            winners.forEach(w => {
                w.chips += splitAmt; w.winAmount = (w.winAmount || 0) + splitAmt;
                winnerNames.push(`<span style="color:var(--gold)">${w.name.split('|')[1] || w.name}</span>`);
            });
            
            const potName = potNumber === 1 ? "‰∏ªÊ±†(Main)" : `ËæπÊ±†(Side ${potNumber-1})`;
            const handCards = winners[0].hand.join(" ");
            if (winners.length === 1) {
                messages.push(`üéâ <strong>${potName}</strong>: ${winnerNames[0]} ‰ª• [${winners[0].finalScore.name}] (${handCards}) Ëµ¢Âæó $${layerPot}`);
            } else {
                messages.push(`‚öñÔ∏è <strong>${potName}</strong>: ${winnerNames.join(", ")} Âπ≥ÂàÜ $${layerPot}`);
            }
            potNumber++;
        }
        playersWithInvest = this.players.filter(p => p.investedThisHand > 0);
    }
    
    this.game.winMessage = messages.join("<br>");
    this.players.forEach(p => p.investedThisHand = 0); 
    this.broadcastState();
  }

  createDeck() {
    const suits = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'], values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    let deck = []; suits.forEach(s => values.forEach(v => deck.push(v + s))); return deck.sort(() => Math.random() - 0.5);
  }
  parseCard(str) { const suit = str.slice(-1); const valStr = str.slice(0, -1); const ranks = {'J':11, 'Q':12, 'K':13, 'A':14}; return { suit, rank: ranks[valStr] || parseInt(valStr) }; }
  calculateHandRank(cards) {
      cards.sort((a, b) => b.rank - a.rank); const flush = this.checkFlush(cards); const straight = this.checkStraight(cards); const c = this.getCounts(cards);
      if (flush && straight) return { value: 9000, name: "ÂêåËä±È°∫" }; if (c.maxCount === 4) return { value: 8000 + c.maxValue, name: "ÂõõÊù°" };
      if (c.maxCount === 3 && c.pairCount >= 1) return { value: 7000 + c.maxValue, name: "Ëë´Ëä¶" }; if (flush) return { value: 6000 + flush.highCard, name: "ÂêåËä±" };
      if (straight) return { value: 5000 + straight.highCard, name: "È°∫Â≠ê" }; if (c.maxCount === 3) return { value: 4000 + c.maxValue, name: "‰∏âÊù°" };
      if (c.pairCount >= 2) return { value: 3000 + c.maxValue, name: "‰∏§ÂØπ" }; if (c.pairCount === 1) return { value: 2000 + c.maxValue, name: "‰∏ÄÂØπ" };
      return { value: cards[0].rank, name: "È´òÁâå" };
  }
  getCounts(cards) { let f = {}; cards.forEach(c => f[c.rank] = (f[c.rank] || 0) + 1); let maxCount = 0; let maxValue = 0; let pairCount = 0; for (let r in f) { if (f[r] > maxCount) { maxCount = f[r]; maxValue = parseInt(r); } if (f[r] >= 2) pairCount++; } return { maxCount, maxValue, pairCount }; }
  checkFlush(cards) { let s = {'‚ô†':[],'‚ô•':[],'‚ô£':[],'‚ô¶':[]}; cards.forEach(c => s[c.suit].push(c)); for (let k in s) { if (s[k].length >= 5) return { highCard: s[k][0].rank }; } return false; }
  checkStraight(cards) { let u = [...new Set(cards.map(c => c.rank))]; if(u.includes(14)) u.push(1); let cons = 1; for (let i = 0; i < u.length - 1; i++) { if (u[i] - 1 === u[i + 1]) { cons++; if (cons === 5) return { highCard: u[i - 3] }; } else cons = 1; } return false; }
  broadcastState() { 
      this.game.pot = this.players.reduce((sum, p) => sum + p.investedThisHand, 0);
      let act = []; this.sessions.forEach(s => { try { s.send(JSON.stringify({ status: this.game.status, players: this.players, game: this.game })); act.push(s); } catch (e) {} }); this.sessions = act; 
  }
}
